{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"documentationSidebar":[{"type":"link","label":"General Design","href":"/intro","docId":"intro","unlisted":false},{"type":"link","label":"Building Blocks","href":"/building_blocks","docId":"building_blocks","unlisted":false},{"type":"category","label":"Data","items":[{"type":"link","label":"data","href":"/data","docId":"data","unlisted":false},{"type":"link","label":"data-local","href":"/data-local","docId":"data-local","unlisted":false},{"type":"link","label":"data-remote","href":"/data-remote","docId":"data-remote","unlisted":false},{"type":"link","label":"data-synthetic","href":"/data-synthetic","docId":"data-synthetic","unlisted":false},{"type":"link","label":"data-scheduling","href":"/data-scheduling","docId":"data-scheduling","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Indicators","items":[{"type":"link","label":"indicators","href":"/indicators","docId":"indicators","unlisted":false},{"type":"link","label":"indicator-development","href":"/indicator-development","docId":"indicator-development","unlisted":false},{"type":"link","label":"indicator-analysis","href":"/indicator-analysis","docId":"indicator-analysis","unlisted":false},{"type":"link","label":"indicator-parsers","href":"/indicator-parsers","docId":"indicator-parsers","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Portfolio","items":[{"type":"link","label":"portfolio","href":"/portfolio","docId":"portfolio","unlisted":false},{"type":"link","label":"portfolio-from-orders","href":"/portfolio-from-orders","docId":"portfolio-from-orders","unlisted":false},{"type":"link","label":"portfolio-from-signals","href":"/portfolio-from-signals","docId":"portfolio-from-signals","unlisted":false}],"collapsed":true,"collapsible":true}],"tutorialsSidebar":[{"type":"link","label":"Installation","href":"/tutorials/installation","docId":"tutorials/installation","unlisted":false},{"type":"link","label":"Basic RSI Strategy","href":"/tutorials/Basic-RSI-Strategy","docId":"tutorials/Basic-RSI-Strategy","unlisted":false},{"type":"link","label":"SuperFast SuperTrend","href":"/tutorials/SuperFast-SuperTrend","docId":"tutorials/SuperFast-SuperTrend","unlisted":false},{"type":"link","label":"Signal Development","href":"/tutorials/Signal-Dev","docId":"tutorials/Signal-Dev","unlisted":false},{"type":"link","label":"Stop Signals","href":"/tutorials/Stop-Signals","docId":"tutorials/Stop-Signals","unlisted":false},{"type":"link","label":"MTF Analysis","href":"/tutorials/MTF-Analysis","docId":"tutorials/MTF-Analysis","unlisted":false},{"type":"link","label":"Portfolio Optimization","href":"/tutorials/Portfolio-Optimization","docId":"tutorials/Portfolio-Optimization","unlisted":false},{"type":"link","label":"Pairs Trading","href":"/tutorials/Pairs-Trading","docId":"tutorials/Pairs-Trading","unlisted":false},{"type":"link","label":"Patterns","href":"/tutorials/Patterns","docId":"tutorials/Patterns","unlisted":false},{"type":"link","label":"Cross Validation","href":"/tutorials/Cross-Validation","docId":"tutorials/Cross-Validation","unlisted":false}]},"docs":{"building_blocks":{"id":"building_blocks","title":"building_blocks","description":"In what follows, we will look at sub-packages, modules, and especially classes that act as building blocks for more advanced functionalities distributed across vectorbt, such as Portfolio. For illustration, we will gradually build our custom class CorrStats that will let us analyze the correlation between two arrays in the most performant and flexible way ðŸ§ ","sidebar":"documentationSidebar"},"data":{"id":"data","title":"data","description":"VectorBT PRO works on Pandas and NumPy arrays, but where those arrays are coming from? Getting the financial data manually is a challenging task, especially when an exchange can return only one bunch of data at a time such that iteration over time ranges, concatenation of results, and alignment of index and columns are effectively outsourced to the user. The task gets only trickier when multiple symbols are involved.","sidebar":"documentationSidebar"},"data-local":{"id":"data-local","title":"data-local","description":"Repeatedly hitting remote API endpoints is costly, thus it's very important to cache data locally. Luckily, vectorbt implements a range of ways for managing local data.","sidebar":"documentationSidebar"},"data-remote":{"id":"data-remote","title":"data-remote","description":"Data classes that subclass RemoteData specialize in pulling (mostly OHLCV) data from remote data sources. In contrast to the classes for locally stored data, they communicate with remote API endpoints and are subject to authentication, authorization, throttling, and other mechanisms that must be taken into account. Also, the amount of data to be fetched is usually not known in advance, and because most data providers have API rate limits and can return only a limited amount of data for each incoming request, there is often a need to iterate over smaller bunches of data and properly concatenate them. Fortunately, vectorbt implements a number of preset data classes that can do all the jobs above automatically.","sidebar":"documentationSidebar"},"data-scheduling":{"id":"data-scheduling","title":"data-scheduling","description":"Most data sources aren't sitting idle: they steadily generate new data. To keep up with new information, we can utilize a schedule manager (or even the simplest while-loop) to periodically run jobs related to data capturing and manipulation.","sidebar":"documentationSidebar"},"data-synthetic":{"id":"data-synthetic","title":"data-synthetic","description":"Synthetic data is data that might have been generated by financial markets but was not. Synthetic price and return data address the financial small data problem and have numerous uses, including testing new investment strategies and feeding data-hungry ML models. They also help us to detect behavior and outlier discrepancies between real and mimicked markets. For example, if our model performs well on a subset of real-world data, we can check it against synthetic data to find out whether we introduced the look-ahead bias or any other Achilles' heel to our model without knowing it.","sidebar":"documentationSidebar"},"indicator-analysis":{"id":"indicator-analysis","title":"indicator-analysis","description":"To analyze an indicator, we can use the indicator instance returned by the run method.","sidebar":"documentationSidebar"},"indicator-development":{"id":"indicator-development","title":"indicator-development","description":"VectorBT PRO implements a ton of functions and arguments for seamless development of indicators. All it takes is an indicator function and a specification of how to handle it.","sidebar":"documentationSidebar"},"indicator-parsers":{"id":"indicator-parsers","title":"indicator-parsers","description":"IndicatorFactory deploys a collection of parsers to simplify creation of indicators, ranging from third-party indicator parsers to a powerful expression parser.","sidebar":"documentationSidebar"},"indicators":{"id":"indicators","title":"indicators","description":"Class IndicatorFactory is a one of the most powerful entities in the vectorbt's ecosystem - it can wrap any indicator function and make it parametrizable and analyzable.","sidebar":"documentationSidebar"},"intro":{"id":"intro","title":"VectorBT PRO Documentation","description":"Navigation","sidebar":"documentationSidebar"},"portfolio":{"id":"portfolio","title":"portfolio","description":"Portfolio refers to any combination of financial assets held by a trader. In the world of vectorbt, \"portfolio\" is a multidimensional structure capable of simulating and tracking multiple independent but also dependent portfolio instances. The main function of a portfolio is to apply a trading logic on a set of inputs to simulate a realistic trading environment, also referred to as \"simulation\". The outputs of such a simulation are orders and other information that can be used by the user in assessing the portfolio's performance, also referred to as \"reconstruction\" or \"post-analysis\". Both phases are isolated in nature, which enables various interesting use cases for quantitative analysis and data science.","sidebar":"documentationSidebar"},"portfolio-from-orders":{"id":"portfolio-from-orders","title":"portfolio-from-orders","description":"Instead of building our custom simulator from scratch, we can make use of one of the preset simulation methods offered by vectorbt. There are three predominantly used methods iterate over the rows and columns, and at each step, convert the current element of all the input data passed by the user into an order request, and process it by updating the current simulation state and by appending the filled order record to an array. This array along with other information can later be used during the reconstruction phase to analyze the simulation.","sidebar":"documentationSidebar"},"portfolio-from-signals":{"id":"portfolio-from-signals","title":"portfolio-from-signals","description":"The method Portfolio.from\\orders (FO), which was discussed previously, is the most primitive simulation method: it takes order information in form of multiple array-like arguments and broadcasts them to a single shape, such that we know exactly what has to be ordered of each asset at each bar. This method requires us to have that information in advance, regardless of any events during the simulation. But what if we wanted to create an order only given that we're not currently in the market, or in general, to make an order dependable on the current simulation state? Such a conditional logic cannot be represented using orders alone - we either need to use a callback, or define more arrays. The former and the latter are both implemented by Portfolio.from\\signals (FS).","sidebar":"documentationSidebar"},"README":{"id":"README","title":"VectorBT PRO Documentation","description":"This is the official documentation for VectorBT PRO, built with Docusaurus 3."},"tutorials/Basic-RSI-Strategy":{"id":"tutorials/Basic-RSI-Strategy","title":"Basic-RSI-Strategy","description":"One of the main powers of vectorbt (PRO) is the ability to create and backtest numerous strategy configurations in the blink of an eye. In this introductory example, we will explore how profitable is the following RSI strategy commonly used by beginners:","sidebar":"tutorialsSidebar"},"tutorials/Cross-Validation":{"id":"tutorials/Cross-Validation","title":"Cross-Validation","description":"Once we develop a rule-based or ML-based strategy, it's time to backtest it. The first time around we obtain a low Sharpe ratio we're unhappy with, we decide to tweak our strategy. Eventually, after multiple iterations of tweaking parameters, we end up with a \"flawless\" combination of parameters and a strategy with an exceptional Sharpe ratio. However, in live trading the performance took a different turn: we essentially tanked and lost money. What went wrong?","sidebar":"tutorialsSidebar"},"tutorials/installation":{"id":"tutorials/installation","title":"installation","description":"Info","sidebar":"tutorialsSidebar"},"tutorials/MTF-Analysis":{"id":"tutorials/MTF-Analysis","title":"MTF-Analysis","description":"By limiting ourselves to only one time frame, we may lose sight of the larger trend, miss clear levels of support and resistance, and overlook high probability entry and stop levels. Monitoring the same pair under different time frames (or time compressions) can help us identify the overall flow of an asset (the trend is your friend, after all) and key chart patterns. In fact, all technical indicators will show different results when used in certain times, and all those results combined can make us draw a more complete picture of the market we're participating in.","sidebar":"tutorialsSidebar"},"tutorials/Pairs-Trading":{"id":"tutorials/Pairs-Trading","title":"Pairs-Trading","description":"A pairs trading strategy is a statistical arbitrage and convergence strategy that is based on the historical correlation of two instruments and involves matching a long position with a short position. The two offsetting positions form the basis for a hedging strategy that seeks to benefit from either a positive or negative trend. A high positive correlation (mostly a minimum of 0.8) of both instruments is the primary driver behind the strategy's profits. Whenever the correlation eventually deviates, we would seek to buy the underperforming instrument and sell short the outperforming instrument. If the securities return to their historical correlation (which is what we bet on!), a profit is made from the convergence of the prices. Thus, pairs trading is used to generate profits regardless of any market condition: uptrend, downtrend, or sideways.","sidebar":"tutorialsSidebar"},"tutorials/Patterns":{"id":"tutorials/Patterns","title":"Patterns","description":"Patterns provide a sense of order in what might otherwise appear chaotic. They tend to emerge everywhere in nature: shapes like circles in road signs or the rectangles in windows and doors. Just like children who gradually learn how to function in a completely unknown environment by looking for regularities, financial market participants need to learn how to navigate their complex, ever-changing environment as well. And just like our little fellows who have parents and teachers to assist their learning process (and Google, of course), we have a wonderful tool to assist ours â€” quantitative analysis.","sidebar":"tutorialsSidebar"},"tutorials/Portfolio-Optimization":{"id":"tutorials/Portfolio-Optimization","title":"Portfolio-Optimization","description":"Portfolio optimization is all about creating a portfolio of assets such that our investment has the maximum return and minimum risk. A portfolio in this regard is the asset distribution of an investor - a weight vector, which can be well optimized for risk appetite, expected rate of return, cost minimization, and other target metrics. Moreover, such optimization can be performed on a regular basis to account for any recent changes in the market behavior.","sidebar":"tutorialsSidebar"},"tutorials/Signal-Dev":{"id":"tutorials/Signal-Dev","title":"Signal-Dev","description":"Signals are an additional level of abstraction added on top of orders: instead of specifying every bit of information on what needs to be ordered at each timestamp, we can first decide on what a typical order should look like, and then choose the timing of issuing such an order. The latter decision process can be realized through signals, which in the vectorbt's world are represented by a boolean mask where True means \"order\" and False means \"no order\". Additionally, we can change the meaning of each signal statically, or dynamically based on the current simulation state; for example, we can instruct the simulator to ignore an \"order\" signal if we're already in the market, which cannot be done by using the \"from-orders\" method alone. Finally, vectorbt loves data science, and so comparing multiple strategies with the same trading conditions but different signal permutations (i.e., order timings and directions) is much easier, less error-prone, and generally leads to fairer experiments.","sidebar":"tutorialsSidebar"},"tutorials/Stop-Signals":{"id":"tutorials/Stop-Signals","title":"Stop-Signals","description":"Our goal is to utilize large-scale backtesting to compare the performance of trading with and without stop loss (SL), trailing stop (TS), and take profit (TP) signals. To make this attempt representative, we will run a huge number of experiments across three different dimensions: instruments, time, and parameters.","sidebar":"tutorialsSidebar"},"tutorials/SuperFast-SuperTrend":{"id":"tutorials/SuperFast-SuperTrend","title":"SuperFast-SuperTrend","description":"While Python is slower than many compiled languages, it's easy to use and extremely diverse. For many, especially in the data science domain, the practicality of the language beats the speed considerations - it's like a Swiss army knife for programmers and researchers alike.","sidebar":"tutorialsSidebar"},"vectorBT-PRO-cookbook":{"id":"vectorBT-PRO-cookbook","title":"vectorBT-PRO-cookbook","description":"DisplayingÂ¶"}}}}